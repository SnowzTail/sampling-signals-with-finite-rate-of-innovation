clear; close all;
% number of diracs
nDiracs = 2;
% number of moments
moments = 5: 10;
% max degree of polynomials
degMax = moments - 1;
% kernels of finite support
len = 2048;
% sampling period
period = 64;
% max amplitue
ampMax = 32;
% number of shifts
nShifts = 31;
% number of iterations
iter = 6;
% time of sampling points
sampPts = 0: 1 / period : (len - 1) / period;
% standard deviation
sigma = 1e1;
% generate dirac signal
[signal, loc, amp] = diracs(len, period, nDiracs, ampMax);
% AWGN noise
noiseSet = sigma * randn(1, max(degMax) + 1);
% vary number of moments
for iMoment = 1: length(moments)
%% Daubechies
% polynomials of max degree N can be reproduced by a scaling function that
% generates wavelets with (N + 1) vanishing moments
[phiT, ~, ~] = wavefun('dB7', iter);
% obtain kernel by shifting scaling function
[kernelSet] = kernel_set(len, period, nShifts, phiT);
% determine polynomials and coefficients of corresponding kernels
[poly, coefs] = polynomial_coefs(len, period, nShifts, degMax(iMoment), sampPts, kernelSet);
%% Recover signal from samples
% sample signal
samples = signal * kernelSet';
tau = zeros(1, degMax(iMoment) + 1);
for iDeg = 0: degMax(iMoment)
    tau(1, iDeg + 1) = dot(coefs(iDeg + 1, :), samples);
end
noise = noiseSet(1: degMax(iMoment) + 1);
% add noise to samples
tauNoisy = tau + noise;
tauNoisyMatrix = zeros(moments(iMoment) - nDiracs, nDiracs + 1);
for iDirac = 1: moments(iMoment) - nDiracs
    tauNoisyMatrix(iDirac, :) = flip(tauNoisy(iDirac: iDirac + nDiracs));
end
%% Total least squares
% svd decomposition
[uTls, lambdaTls, vTls] = svd(tauNoisyMatrix);
% filter is determined by the last column of v
filterCoefsTls = vTls(:, end);
% determine dirac locations by annihilating filter
locEstTls = sort(zero(tf(filterCoefsTls', 1)))';
% Vandermonde system
locMatrix = fliplr(vander(locEstTls))';
% weighted sum of the observed samples
tauMatrix = tau(1: nDiracs)';
% samples are related to locations and weights; first two terms are already
% known, solve for weights
ampEstTls = (locMatrix \ tauMatrix)';
%% Cadzow's
% svd decomposition
[uCadzow, lambdaCadzow, vCadzow] = svd(tauNoisyMatrix);
% tau matrix is full rank in the noisy case
isDeficient = rank(tauNoisyMatrix) == nDiracs;
toeplitz = zeros(size(tauNoisyMatrix));
% iterate tau matrix to satisfy Toeplitz and rank deficient to reduce noise
while ~isDeficient
    % the nDiracs largest diagonal coefficients correspond to diracs;
    % others are generated by noise and should be set to zero
    lambdaCadzow(size(lambdaCadzow, 2), size(lambdaCadzow, 2)) = 0;
%     diagonal = diag(lambdaCadzow);
%     diagonal(nDiracs + 1: end) = 0;
%     lambdaCadzow = diag(diagonal);
    % reconstruct tau matrix
    tauNoisyMatrix = uCadzow * lambdaCadzow * vCadzow';
    % it is not Toeplitz now; average diagonals to make it Toeplitz
    for iRow = 1: size(tauNoisyMatrix, 1)
        for iCol = 1: size(tauNoisyMatrix, 2)
            toeplitz(iRow, iCol) = mean(diag(tauNoisyMatrix, iCol - iRow));
        end
    end
    tauNoisyMatrix = toeplitz;
    % check whether it is full rank
    isDeficient = rank(tauNoisyMatrix) == nDiracs;
    [uCadzow, lambdaCadzow, vCadzow] = svd(tauNoisyMatrix);
end
% filter is determined by the last column of v
filterCoefsCadzow = vCadzow(:, end);
% determine dirac locations by annihilating filter
locEstCadzow = sort(zero(tf(filterCoefsCadzow', 1)))';
% Vandermonde system
locMatrix = fliplr(vander(locEstCadzow))';
% weighted sum of the observed samples
tauMatrix = tau(1: nDiracs)';
% samples are related to locations and weights; first two terms are already
% known, solve for weights
ampEstCadzow = (locMatrix \ tauMatrix)';
%% Signal plot
subplot(length(moments), 1, iMoment);
stem(loc, amp, 'k-o');
hold on;
stem(locEstTls, ampEstTls, 'r--x');
hold on;
stem(locEstCadzow, ampEstCadzow, 'b:*');
xlabel('Time');
ylabel('Amplitude');
legend('Original Diracs', 'Estimated by TLS', 'Estimated by Cadzow', 'location', 'bestoutside');
title(['Reconstruction of Dirac Signal When Moments = ' num2str(moments(iMoment))]);
disp(['----------   Moments = ' num2str(moments(iMoment)) '	----------']);
disp(['Exact location:                ' num2str(loc)]);
disp(['Estimated location by TLS:     ' num2str(locEstTls)]);
disp(['Estimated location by Cadzow:  ' num2str(locEstCadzow)]);
disp(['Exact amplitude:               ' num2str(amp)]);
disp(['Estimated amplitude by TLS:    ' num2str(ampEstTls)]);
disp(['Estimated amplitude by Cadzow: ' num2str(ampEstCadzow)]);
end
