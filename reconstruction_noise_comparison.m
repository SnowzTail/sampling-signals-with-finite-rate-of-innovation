clear; close;
% number of diracs
nDiracs = 2;
% number of moments
nMoments = 5;
% max degree of polynomials
degMax = nMoments - 1;
% kernels of finite support
len = 2048;
% sampling period
period = 64;
% max amplitue
ampMax = 32;
% number of shifts
nShifts = 31;
% number of iterations
iter = 6;
% time of sampling points
sampPts = 0: 1 / period : (len - 1) / period;
% standard deviation
sigma = 1e1;
% AWGN noise
noise = sigma * randn(1, degMax + 1);
%% Daubechies
% polynomials of max degree N can be reproduced by a scaling function that
% generates wavelets with (N + 1) vanishing moments
[phiT, ~, ~] = wavefun('dB5', iter);
% obtain kernel by shifting scaling function
[kernelSet] = kernel_set(len, period, nShifts, phiT);
% determine polynomials and coefficients of corresponding kernels
[poly, coefs] = polynomial_coefs(len, period, nShifts, degMax, sampPts, kernelSet);
%% Recover signal from samples
% generate dirac signal
[signal, loc, amp] = diracs(len, period, nDiracs, ampMax);
% sample signal
samples = signal * kernelSet';
tau = zeros(1, degMax + 1);
for iDeg = 0: degMax
    tau(1, iDeg + 1) = dot(coefs(iDeg + 1, :), samples);
end
% add noise to samples
tauNoisy = tau + noise;
tauNoisyMatrix = zeros(nMoments - nDiracs, nDiracs + 1);
for iDirac = 1: nMoments - nDiracs
    tauNoisyMatrix(iDirac, :) = flip(tauNoisy(iDirac: iDirac + nDiracs));
end
%% Total least squares
% svd decomposition
[uTls, lambdaTls, vTls] = svd(tauNoisyMatrix);
% filter is determined by the last column of v
filterCoefsTls = vTls(:, end);
% determine dirac locations by annihilating filter
locEstTls = sort(zero(tf(filterCoefsTls',1)))';
% Vandermonde system
locMatrix = fliplr(vander(locEstTls))';
% weighted sum of the observed samples
tauMatrix = tau(1: nDiracs)';
% samples are related to locations and weights; first two terms are already
% known, solve for weights
ampEstTls = (locMatrix \ tauMatrix)';
%% Cadzow's
% svd decomposition
[uCadzow, lambdaCadzow, vCadzow] = svd(tauNoisyMatrix);
% tau matrix is full rank in the noisy case
isDeficient = det(tauNoisyMatrix) == 0;
toeplitz = zeros(size(tauNoisyMatrix));
% iterate tau matrix to satisfy Toeplitz and rank deficient to reduce noise
while ~isDeficient
    % the nDiracs largest diagonal coefficients correspond to diracs;
    % others are generated by noise and should be set to zero
    diagonal = diag(lambdaCadzow);
    diagonal(nDiracs + 1: end) = 0;
    lambdaCadzow = diag(diagonal);
    % reconstruct tau matrix
    tauNoisyMatrix = uCadzow * lambdaCadzow * vCadzow';
    % it is not Toeplitz now; average diagonals to make it Toeplitz
    for iRow = 1: size(tauNoisyMatrix, 1)
        for iCol = 1: size(tauNoisyMatrix, 2)
            toeplitz(iRow, iCol) = mean(diag(tauNoisyMatrix, iCol - iRow));
        end
    end
    tauNoisyMatrix = toeplitz;
    % check whether it is full rank
    isDeficient = rank(tauNoisyMatrix) == nDiracs;
    [uCadzow, lambdaCadzow, vCadzow] = svd(tauNoisyMatrix);
end
% filter is determined by the last column of v
filterCoefsCadzow = vCadzow(:, end);
% determine dirac locations by annihilating filter
locEstCadzow = sort(zero(tf(filterCoefsCadzow',1)))';
% Vandermonde system
locMatrix = fliplr(vander(locEstCadzow))';
% weighted sum of the observed samples
tauMatrix = tau(1: nDiracs)';
% samples are related to locations and weights; first two terms are already
% known, solve for weights
ampEstCadzow = (locMatrix \ tauMatrix)';
%% Signal plot
stem(loc, amp);
hold on;
stem(locEstTls, ampEstTls);
hold on;
stem(locEstCadzow, ampEstCadzow);
xlabel('Time');
ylabel('Amplitude');
legend('Original Diracs', 'Estimated by TLS', 'Estimated by Cadzow');
title('Reconstruction of Dirac Signal with Kernels Reproducing Polynomials');
